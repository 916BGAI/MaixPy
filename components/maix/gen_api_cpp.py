'''
    @brief Generate C++ code for MaixPy API
    @license Apache 2.0
    @author Neucrack@Sipeed
    @date 2023.10.23
'''

import os

def generate_api_cpp(api_tree, headers, out_path = None):
    content = '''
// This file is generated by MaixPy gen_api.py,
// !! DO NOT edit this file manually

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/complex.h>
#include <pybind11/functional.h>
#include <pybind11/chrono.h>

{}

#include "maixpy.hpp"


using namespace maix;
using namespace maix::peripheral;

namespace py = pybind11;


PYBIND11_MODULE(_maix, m) {{
    {}
}}
'''
    code = []
    maix = api_tree["members"]["maix"]
    code.append('m.doc() = "{}";'.format(maix["doc"]))
    def gen_members(members, _code, parent_var, parent_name, parent_type, parent_names):
        for k, v in members.items():
            if type(v["doc"]) == str:
                doc = v["doc"]
            else:
                doc = v.get("doc", {}).get("py_doc", "")
                if not doc:
                    doc = v["doc"].get("brief", "")
            doc = doc.replace("\n", "\\n").replace('"', '\\"')
            if v["type"] == "module":
                sub_m_name = "m_{}".format(k)
                _code.append('auto {} = {}.def_submodule("{}", "{}");'.format(sub_m_name, parent_var, k, doc))
                gen_members(v["members"], _code, sub_m_name, k, v["type"], parent_names + [k])
            elif v["type"] == "class":
                sub_obj_name = "class_{}".format(k)
                v_names = parent_names + [k]
                _code.append('auto {} = py::class_<{}>({}, "{}");'.format(sub_obj_name, "::".join(v_names), parent_var, k))
                gen_members(v["members"], _code, sub_obj_name, k, v["type"], parent_names + [k])
            elif v["type"] == "func":
                kwargs_str = ", ".join(['py::arg("{}") {}'.format(x[1], '= {}'.format(x[2]) if x[2] is not None else "") for x in v["args"]])
                if kwargs_str:
                    kwargs_str = ", " + kwargs_str
                if k == "__init__":
                    func_name = parent_name
                    _code.append('{}.def(py::init<{}>(){});'.format(parent_var, ", ".join([x[0] for x in v["args"]]), kwargs_str))
                elif k == "__del__":
                    raise Exception("not support __del__ yet")
                else:
                    func_name = v["name"]
                    # if parent_type == "class":
                    _code.append('{}.def{}("{}", static_cast<{} ({})({})>({}{}), py::return_value_policy::take_ownership, "{}"{});'.format(
                                parent_var, "_static" if v["static"] else "", k,
                                v["ret_type"],
                                "::".join(parent_names + ["*"]) if (parent_type == "class" and not v["static"]) else "*",
                                ", ".join([x[0] for x in v["args"]]),
                                "&{}::".format("::".join(parent_names)) if len(parent_names) > 0  else "", func_name,
                                doc, kwargs_str))
                    # else:
                    #     _code.append('{}.def{}("{}", {}{}, "{}"{});'.format(parent_var, "_static" if v["static"] else "",k,
                    #                         "&{}::".format("::".join(parent_names)) if len(parent_names) > 0  else "", func_name,
                    #                         doc, kwargs_str))

            elif v["type"] == "var":
                if parent_type == "class":
                    v_names = parent_names + [k]
                    if v["readonly"]:
                        _code.append('{}.def_readonly{}("{}", &{});'.format(parent_var, "_static" if v["static"] else "", k, "::".join(v_names) ))
                    else:
                        _code.append('{}.def_readwrite{}("{}", &{});'.format(parent_var, "_static" if v["static"] else "", k, "::".join(v_names)))
                else:
                    _code.append('{}.attr("{}") = {};'.format(parent_var, k, "::".join(parent_names + [k])))
            elif v["type"] == "enum":
                _code.append('py::enum_<{}>({}, "{}")'.format("::".join(parent_names + [k]), parent_var, k))
                for enum_k, v, comment in v["values"]:
                    v_names = parent_names + [k, enum_k]
                    _code.append('    .value("{}", {})'.format(enum_k, "::".join(v_names)))
                _code.append(';')


    gen_members(maix["members"], code, parent_var="m", parent_name="maix", parent_type="module", parent_names=[])

    code = "\n    ".join(code)
    headers_final = []
    for h in headers:
        headers_final.append('#include "{}"'.format(os.path.basename(h)))
    header_str = "\n".join(headers_final)
    content = content.format(header_str, code)
    if out_path:
        if os.path.dirname(out_path):
            os.makedirs(os.path.dirname(out_path), exist_ok=True)
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(content)
    return content
